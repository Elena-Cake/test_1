// ```
//________________________________ 
// Типы данных
// _______________________________

// (1)примитивы и (2)ссылочные типы данных:
    // 1) string, boolean, number, BigInt, null, undefined, symbol (7)
    //  NAN - не примитив, не тип данных, работает только в контексте чисел
    // 2) object (и все прототипы)

// В чем отличие?
    // null -  нет такого объекта\переменной или свойства, не объявляли
    // undefined - свойство объекта есть, но сейчас не определено

// В чем отличие?
    // примитивы - хранят ячейку памяти = само значение
    //            иммутабельны (мы не можем заменить часть примитива, только целиком):
                    // const str = 'aacd'
                    // str[1]; // a
                    // str[1] = 'b'; //не сработает
    // ссылочные - хранят ссылку(указатель) на ячейку памяти
    //            не иммутабельны 



//________________________________ 
// Динамическая типизация
// _______________________________

// при написании кода идет 2 этапа переработки кода
// js - интерпритируемый язык с присутствием компилирования

    // const string = '123';
    // const number = 10;
    // string + number; // первый стринг -> преобразую все к стринг

  // V8 -> 1) компилирует весь код и проверяет на ошибки
  //       2) компилирует 2 раз

  // динамическая типизация - непредсказуемость. 
  //      Если нужно преобразовать => преобразуй явно: Number(string)



//________________________________ 
// Методы обхода массивов 
// (функций, объектов и тд)
// _______________________________

// Методы:
//    forEach, map, reduce

// Циклы:
//    while, for

// ``` ( внутри можно раскоментировать)

      // const array = [1,2,3,4];
      // Object.prototype.hello = function (){}
      // Array.prototype.sum = function (){}

      // array.foo = 'foo'

      // for (let i = 0; i<10; i++) {} // самый быстрый способ обхода массивов

      // for (let num in array) { // проходит по все элементам массива (по ключам массива), 
      //                         // а потом идет по прототипам и выводит то, что добавили
      //   console.log('in', num);
      //   if (array.hasOwnProperty(num)) {} //чтобы in работал как of
      // }
      //     // in 0
      //     // in 1
      //     // in 2
      //     // in 3
      //     // in foo   - в массив добавлено свойство
      //     // in sum   - прототип Array
      //     // in hello - прототип Object

      // for (let num of array) { // проходит только по самому массиву
      //   console.log('of', num);
      // }
      //     // of 1
      //     // of 2
      //     // of 3
      //     // of 4

// ```



//________________________________ 
// Итерируемый объект и Итератор
// _______________________________

// Когда  оы работает с функциями, объектами и тд... у него есть 2 протокола взаимодействия

// итерируемый - когда есть влияние на каждом шаге прохода
// итератор - функция, которая определяет СПОСОБ получения значений

// _______________________________
// ИТЕРАТОР

// ```

      // const array = [1,2,3]

      // function makeIterator(array) {
      //   let countIndex = 0;
      //   return {
      //     next: function () {
      //       return countIndex < array.length ? {value : array[countIndex++], done: false}
      //                                       : {done: true}
      //     }
      //   }
      // }

      // const foo = makeIterator(array)
      // console.log(foo.next());       //{ value: 1, done: false }
      // console.log(foo.next());       //{ value: 2, done: false }
      // console.log('something code');
      // console.log(foo.next());       //{ value: 3, done: false }
      // console.log(foo.next());       //{ done: true }

// ```

// итератор - функция, у которой есть значение на каждом шаге. здесь, если 2 консоль лога, 
//            потом какой то код... потом лог, он продолжит со следующего шага.
// применяется, например, для предотвращения 600 нажатий на кнопку (вызываем next и сравниваем id),
//            чтобы не выполнялся код многократно, когда это не имеет смысла

// итератор работает с чем угодно (массивы, объекты и тд), что можно проитерировать


// _______________________________
// ИТЕРИРУЕМЫЙ ОБЪЕКТ

// выполняет тоже, что и итератор:
// тоже есть next, тоже есть значение на каждом шаге и выдает объект {value: '', done: ''}.

// работает только с объектами

// Symbol.iterator - метод, с помощью котороко мы можем
// взаимодействовать с тем, что внутри объекта

// Пример:

// ```

      // const generateNumbers = {
      //   start: 1,
      //   end: 4,

      //  //__________эта часть ода показывает как можно переписать метод итератора на ГЕНЕРАТОР
      //  //          это короче, после возвращаемого значения может работать дальше (в отличие от итератора)

      //    *[Symbol.iterator]() {   //символ * показывает, что это генератор ()
      //        for (let value = this.start; value <= this.end; value++) {
      //          yield value
      //        }
      //   }
      // }
      // console.log([...generateNumbers]);           // удобство вывода при помощи rest оператора
      //             // [
      //             //   1, 2, 3, 4
      //             // ]
      // //__________

      // generateNumbers[Symbol.iterator] = function () {  // создаем метод для объекта (можно и при объявлении объекта)
      //   return {
      //     current: this.start,   // нынешнее значение
      //     end: this.end,         // конец
      //     next() {               
      //       if (this.current <= this.end) {
      //         return {value: this.current++, done: false}
      //       } else {
      //         return {done: true}
      //       }
      //     }
      //   }
      // }

      // for (let num of generateNumbers) {    
      //   console.log(num)
      // }
      //           // 1
      //           // 2
      //           // 3
      //           // 4

// ``` 

// 1. запускаем цикл for по объекту с 2 значениями
// 2. js видит, что у объекта задан метод [Symbol.iterator] и читает его, натыкается на next 
//    и признает, что ему нужно будет возвращать каждую итерацию
// 3. в next js видит done как системную переменную а значение сам достает из current и выводит его

// Symbol изначально создавался как тип данных, позволяющий создавать уникальные значения внутри объектов



// _______________________________
// ГЕНЕРАТОР 

// функции, который имеют особенность написания '*' и начинается со слова generate

// отличается наличием ключевых слов: return (есть и у пред.), 
                                    // throw ("выкинуть ошибку", return не сработает после него) -> throw new Error('error') ,
                                    // yield (возвращает промежуточное значение)


// с yield будет находить при каждом вызове следующее поддходящее число 
// (в отличие от функции, которая дойдет до первого подходящего числа и завершится)

// ```

      // function* generateNumbers() {
      //   yield 1;
      //   console.log('123');

      //   const number = 1234;
      //   yield 2;
      //   return 3
      // }

      // let generateCheck = generateNumbers();

      // console.log(generateCheck.next());  // { value: 1, done: false }
      // console.log(generateCheck.next());  // 123
      //                                     // { value: 2, done: false }
      // console.log(generateCheck.next());  // { value: 3, done: true }
      // console.log(generateCheck.next());  // { value: undefined, done: true }

// ```

// у generateCheck есть 3 метода: next (следущее), return (конечное), throw (ошибка)


//________________________________ 
// Каррирование
// _______________________________

// ```

      // function sum (a,b) {
      //   if (a,b) {
      //     return a+b;    // console.log(sum(2,10));
      //   }

      //   if (!a) return function (a,b) { return a + b};   // console.log(sum()(2,10));
      //   if (!b) return function (b)   { return a + b};   // console.log(sum(2)(10));
      // }

      // const b = sum(10);

      // console.log(sum(2,10));   // 12
      // console.log(sum(2)(10));  // 12
      // console.log(sum()(2,10)); // 12

// ```

// используется тогда, когда требуется учитывать возможность передачи только одной переменной

// пробовать через bind (для себя)



//________________________________ 
// Приватные методы класса
// _______________________________

// ```

      // class Animal {
      //   #voice
      //   #type
      //   constructor(voice, type) {
      //     this.voice = voice;
      //     this.type = type;
      //   }

      //   talk() {
      //     console.log(this._voice);
      //   }
      // }

      // const dog = new Animal('bark', 'pudel');

      // dog.talk();
      // // dog.#voice = 'meow'; // при попытке перезаписи приватного свойства js ругается
      // dog.talk();

// ```



//________________________________ 
// Операторы опциональных полей
// _______________________________

// ```

      // const obj = {
      //   a: {
      //     b: 20
      //   },
      //   c: 30,
      //   d: {
      //     e: 100
      //   }
      // }

      // console.log(obj.a.b.c?.e);

// ```

// вызываем метод у undefined (b)...

// вызов опц.полей  нужен для обезопашевания программы от прихода undefined
// тогда, когда через раз приходит undefined, например



//________________________________ 
// const let var
// _______________________________

// const - не переопределяется
// let - переопределяется, доступна внутри блока - внутри {} (у ф-ции, for, if и тд)
// var - глобальная, доступна внутри функции

// ```

      // function some(){ //функция
      //   for (let i = 0; i<1; i++) { //блок
      //     var a = 1
      //     let b = 2
      //   }
      //   console.log(a);     // 1
      //   // console.log(b);  // ReferenceError: b is not defined
      // }
      // some();

// ```

// всплытие?



//________________________________ 
// Замыкание
// _______________________________

// лексическое окружение - ф-ции запоминают свое лексическое окружение 
//                         и удаляют его после своего завершения


// ```

      //   //  внешнее окружение test
      // function test() { 
      //   //  внутреннее окружение test
      //     let counter = 0;
      //             // test = внешнее окржение этой ф-ции
      //     return function () {
      //             // внутреннее окружение
      //         console.log(counter);
      //         counter++
      //     }
      // }
      // const foo = test();
      // foo(); // 0
      // foo(); // 1
      // foo(); // 2

// ```

// мусорщик js работает так, что он не имеет права удалять внешнее окружение ф-ции
// поэтому 'let counter = 0;' не удаляется даже после отработки функции test



//________________________________ 
// Прототипы
// _______________________________

// прототип - это 'предок' любой переменной. По ссылке любая переменная идет к своим прототипам
//            вплоть до Object и берет необходимые методы по пути

// ```