// переместить в теорию
// ________________________
// SPA (Simple Page App
// ________________________

// история:

//          tradition page lifetime:

// ---------      запрос--------->      ---------
// |       |      <----------HTML,js    |       |   //вся разметка в html, js маленький только для действий кнопок
// |Client |  есть что-либо новое? -->  |Server |
// |       |      <----------HTML       |       |   //даже если поменялся 1 символ
// ---------                            ---------   //заново идет скачка всего приложения

// раньше присылался большой html и маленький js, страница полностью отрисовывалась заново
// при любых изменениях (новое сообщение или проставление лайка, например)


//          Simple Page App:

// ---------      запрос--------->      ---------
// |       |      <----------html,JS    |       |   //html маленький, основная разметка и логика в js
// |Client |  есть что-либо новое? -->  |Server |
// |       |      <----------{json}     |       |
// ---------                            ---------

// все изменения внешнего интерфейса происходят на стороне клиента (раньше это делал сервер)

// + огромная экономия трафика клиента
// + разгрузка сервера
// + появление профессии фронта впринципе то)



// доп материал 
// modules AMD
// require.js
// ________________________________________________



// JSX  - язык, который позволяет писать html внутри скрипта js

// ________________
// Компонента - ф-ция, принимает пропсы и возвращающая разметку jsx
// создавая компоненту, мы как бы создаем тег

// пропсы-входящие данные, задаваемые как атрибуты тега

// компонента App:
const App = () => {
    return (
        <div className="App">
            что-то
        </div>
    );
}
import { BlockList } from 'net';
// может возвращать только один корневой тег!

// _________________

// в git bash можно открыть интерфейс комитов
// gitk --all&

// ________________________

// css модули

// для написания коротких названий классов, но сохранение правил внутри компоненты
// можно сделать css модуль:

// 1. назвать css файл как Name.module.css
// 2. импортировать как класс : import s from './Name.module.css'
// тогда s это объект типа
// class : 'Name_class__randomNumbers'

// 3. в разметку писать className={s.class}

// _______________


//UI & Bll

// UI (User Interface)                |      BLL(business logic layer)

// слой(файлы ф-ции и тд,             |     слой(-//-), отвечающие за хранение данных
// которые отвечают за отрисовку      |
// интерфейса)

//react                               |         redux
//_____                               |         ________
//                <-----------props   |
// Profile


//_______________________________

// FLUX - архетектура потока данных
//      (redux - ее реализация)

//              state in props
//         ----------------->
// BLL                             UI
//         <-----------------
//              action in UI

// Суть заключается в том, что когда пользователь совершает действие, оно не должно влиять на интерфйс напрямую. 
// в первую очередь должен поменяться state в BLL, потом отрисоваться интерфейс.

// например, лайк? UI -> BLL занеси в базу лайк! -> 
//                      (BLL) ок, сделано, отрисуй новые данные -> 
//                      (UI) ок

// _______________________

// Паттерн observer- наблюдатель (например onClick onChange)

// _________________________

//REDUX (история)

// содержит как бы класс с данными и методом, который включает в себя всю логику по изменению этих данных

let store = {
    state: {},
    dispatch(action) { // {type: 'ADD-POST'}
        if (action.type === 'ADD-POST') {
            //do smth
            this.state.newPostMessage = action.newPostMessage
        } else if (action.type === 'ADD-POST') {
            //do different thing
        }
    }
}

//action -это всегда объект, содержащий тип действия, согласно которому будет определяться
// что будет сделано и опционально другие данные, например такой вызов:

dispatch({ type: 'ADD-POST', newPostMessage: text })
// Route

// route - это "слушатель" адресной строки. заменяет содержимое на нужное

import { BrowserRouter, Route, Routes } from 'react-router-dom';
const Appp = () => {
    return (
        // обязательная обертка всего App:
        <BrowserRouter>
            <div className="app__wrapper">
                {/* ... */}
                {/* место, где будет меняться контент согласно добавочной строке с ссылке*/}
                <div className='app__wrapper_content'>
                    {/* обязательная обертка для вариантов замены контента */}
                    {/* в Routes дочерними могут быть только Route*/}
                    <Routes>
                        <Route path="/profile" element={<Profile />} />
                        <Route path="/dialogs" element={<Dialogs />} />
                    </Routes>
                </div>
            </div>
        </BrowserRouter>
    )
}



// _____________________

// NavLink

// NavLink - замена <a> в реакте, которая сама отменяет перезагрузку страницы
// to = href, но только обрезанному по добавочной строке

import { NavLink } from "react-router-dom";

<div className={classes.nav__menu}>
    <NavLink to="/">Main page</NavLink>
    <NavLink to="/music">Music</NavLink>
    {/*         ->to http://localhost:3000/music */}
</div>

// автоматически ставит класс 'active' на активную ссылку (с сss модулем запара)

// неидеальное решение:
// className = {(state) => state.isActive ?
//     `${s.navlink} ${s.active}` : `${s.navlink}`}>

// activeClassName - атрибут, который должен задавать класс активной ...
//                  но не задает...

// _____________________

// REDUSER

// state -------->   reduser  ---------->   new state

// reduser - чистая функция, принимающая state и action, применяет 2 к 1 ,если требуется, и возвращает новый state

// state - бизнес слой
// action - объект, у которого есть type (обязательно!) и какие то требуемые данные

// action как правило меняет какие-то данные в state (UPDATE_NEW_MESSAGE_BODY, SEND_MESSAGE...)

// редюсер это такая функция, которая разгружает диспач в стейте, берет на себя логику какой-то ветви стейта
//

// ________________________
// контейнерная компонента VS презентационная

// контейнерная компонента нужна для того, что бы оградить внутреннюю компоненту от общения
//           с конкретными путями стора... "очистить" ее

// презентационная компонента - это такая, которая имеет максимально минимальное знание для своего функционирования.
//          это нужно, что бы можно было ее переиспользовать

// __________________________________
// детерминированость

// присуща чистым функциям (принимают(необязательно) и возвращают(обязательно) данные)
// если мы отдаем одни и те же данные, то получим один и тот же ответ
// если мы подадим разные данные, получим разный ответ

// чистая функция не должна изменять внешние глобальные данные

// имьютабельноть- фунция не может изменить входные данные, должна меняться копия данных


// __________________________
import React from "react";

//  ОБЯЗАТЕЛЕН если есть JSX в файле
// потому что он будет преобразован к JS под капотом. это нужно для браузера


// ___________________________

// UI               BLL                 DAL(data acsess laier)
// react            redux               axios
//                                      уровень api общения



// САНКИ!!!!
// _____________________
// санка (thunk) -это функция, которая собирает в себя какие то действия одного секшена, 
//  например, 
// "покажи крутилку"-"отправь запрос"-"получи ответ"-"скрой крутилку"-"отобрази результат"
// 
// это все логически связанные действия, включающие асинхронку

const addPost = (dispatch) => {
    dispatch(onLoading())
    axios.post({ messae }).then(() => {
        dispatch(addPost(message))
        dispatch(offLosding())
    })
}
// чтобы взять сообщение, нужно сделать замекание (доступ к данным родительской фуекции)

const addPostThunkCreator = (message) => (dispatch) => {
    dispatch(onLoading())
    axios.post({ message }).then(() => {
        dispatch(addPost(message))
        dispatch(offLosding())
    })
}

dispatch(addPostThunkCreator("hello"))

// обычно стор отправляет в редъюсеры экшены, санки он не умеет обрабатывать... поэтому нажно создать
// thunk middle waier - такую логику, которая будет определять, что пришло в стор:
// action или санка
//  и либо пересылать экшен в редюсер, либо сапускать санку, которая делает асинхронку и
// передает диспатчи, которые вернуться в стор, попадут опять в thunk mw и пойдут дальше в редюсер
