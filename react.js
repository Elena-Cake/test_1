// переместить в теорию
// ________________________
// SPA (Simple Page App
// ________________________

// история:

//          tradition page lifetime:

// ---------      запрос--------->      ---------
// |       |      <----------HTML,js    |       |   //вся разметка в html, js маленький только для действий кнопок
// |Client |  есть что-либо новое? -->  |Server |
// |       |      <----------HTML       |       |   //даже если поменялся 1 символ
// ---------                            ---------   //заново идет скачка всего приложения

// раньше присылался большой html и маленький js, страница полностью отрисовывалась заново
// при любых изменениях (новое сообщение или проставление лайка, например)


//          Simple Page App:

// ---------      запрос--------->      ---------
// |       |      <----------html,JS    |       |   //html маленький, основная разметка и логика в js
// |Client |  есть что-либо новое? -->  |Server |
// |       |      <----------{json}     |       |
// ---------                            ---------

// все изменения внешнего интерфейса происходят на стороне клиента (раньше это делал сервер)

// + огромная экономия трафика клиента
// + разгрузка сервера
// + появление профессии фронта впринципе то)



// доп материал 
// modules AMD
// require.js
// ________________________________________________



// JSX  - язык, который позволяет писать html внутри скрипта js

// ________________
// Компонента - ф-ция, принимает пропсы и возвращающая разметку jsx
// создавая компоненту, мы как бы создаем тег

// пропсы-входящие данные, задаваемые как атрибуты тега

// компонента App:
const App = () => {
    return (
        <div className="App">
            что-то
        </div>
    );
}
// может возвращать только один корневой тег!

// _________________

// в git bash можно открыть интерфейс комитов
// gitk --all&

// ________________________

// css модули

// для написания коротких названий классов, но сохранение правил внутри компоненты
// можно сделать css модуль:

// 1. назвать css файл как Name.module.css
// 2. импортировать как класс : import s from './Name.module.css'
// тогда s это объект типа
// class : 'Name_class__randomNumbers'

// 3. в разметку писать className={s.class}

// _______________

// Route

// route - это "слушатель" адресной строки. заменяет содержимое на нужное

import { BrowserRouter, Route, Routes } from 'react-router-dom';
const Appp = () => {
    return (
        // обязательная обертка всего App:
        <BrowserRouter>
            <div className="app__wrapper">
                {/* ... */}
                {/* место, где будет меняться контент согласно добавочной строке с ссылке*/}
                <div className='app__wrapper_content'>
                    {/* обязательная обертка для вариантов замены контента */}
                    {/* в Routes дочерними могут быть только Route*/}
                    <Routes>
                        <Route path="/profile" element={<Profile />} />
                        <Route path="/dialogs" element={<Dialogs />} />
                    </Routes>
                </div>
            </div>
        </BrowserRouter>
    )
}

// _____________________

// NavLink

// NavLink - замена <a> в реакте, которая сама отменяет перезагрузку страницы
// to = href, но только обрезанному по добавочной строке

import { NavLink } from "react-router-dom";

<div className={classes.nav__menu}>
    <NavLink to="/">Main page</NavLink>
    <NavLink to="/music">Music</NavLink>
    {/*         ->to http://localhost:3000/music */}
</div>

// автоматически ставит класс 'active' на активную ссылку (с сss модулем запара)

// неидеальное решение:
// className = {(state) => state.isActive ?
//     `${s.navlink} ${s.active}` : `${s.navlink}`}>

// activeClassName - атрибут, который должен задавать класс активной ...
//                  но не задает...

// _____________________
